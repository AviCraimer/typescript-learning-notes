{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "type VariableBase = Readonly<{\r\n    role: \"Variable\";\r\n    name: string;\r\n    toString: () => string;\r\n}>;\r\n\r\ntype VariableFree = VariableBase & { readonly free: true };\r\n\r\ntype VariableBound = VariableBase & { readonly free: false };\r\ntype Variable = VariableBound | VariableFree;\r\ntype Abstraction = Readonly<{\r\n    role: \"Abstraction\";\r\n    components: [parameter: VariableBound, body: Lambda];\r\n    toString: () => string;\r\n}>;\r\n\r\ntype Application = Readonly<{\r\n    role: \"Application\";\r\n    components: [abstraction: Lambda, argument: Lambda];\r\n    toString: () => string;\r\n}>;\r\n\r\ntype Lambda = Variable | Abstraction | Application;"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "function toString(this: Lambda): string {\r\n    if (this.role === \"Variable\") {\r\n        return this.name;\r\n    } else if (this.role === \"Abstraction\") {\r\n        const [parameter, body] = this.components;\r\n        return `Î»${parameter.toString()}.[ ${body.toString()} ]`;\r\n    } else if (this.role === \"Application\") {\r\n        const [abstraction, argument] = this.components;\r\n        return `${abstraction.toString()} (${argument.toString()})`;\r\n    }\r\n    const nothing: never = this;\r\n    return nothing;\r\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "function Var(name: string, free?: true): VariableFree;\r\nfunction Var(name: string, free?: false): VariableBound;\r\nfunction Var(name: string, free?: undefined): VariableFree;\r\nfunction Var(name: string, free?: boolean): Variable {\r\n    return { role: \"Variable\", name, free: free ?? true, toString };\r\n}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "const x = Var(\"x\");\r\nconst y = Var(\"y\");\r\nconst f = Var(\"f\");\r\nconst g = Var(\"g\");\r\ng"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  role: \u001b[32m'Variable'\u001b[39m,",
                                "  name: \u001b[32m'g'\u001b[39m,",
                                "  free: \u001b[33mtrue\u001b[39m,",
                                "  toString: \u001b[36m[Function: toString]\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "const Substitution = (\r\n    x: Variable,\r\n    expression: Lambda,\r\n    substitute: Lambda\r\n): Lambda => {\r\n    if (expression.role === \"Variable\") {\r\n        //If the expression a variable matching x, replace it with substitute expression\r\n        if (expression.name === x.name && expression.free === x.free) {\r\n            return substitute;\r\n        } else {\r\n            //Otherwise return it unmodified\r\n            return expression;\r\n        }\r\n    } else if (expression.role === \"Abstraction\") {\r\n        //If the expression is itself an abstraction, we have to consider scope, we don't replace if a variable with a narrow scope has the same name as our x.\r\n        const [innerParam, body] = expression.components;\r\n\r\n        if (x.name === innerParam.name) {\r\n            //Within this expression x is bound to the inner lambda parameter \"innerParam\". So we don't replace it under the inner scope.\r\n            return expression as Lambda;\r\n        } else {\r\n            //If the innerParam has a different name, we replace the x variables inside the inner abstraction.\r\n            return {\r\n                ...expression,\r\n                components: [innerParam, Substitution(x, body, substitute)],\r\n            };\r\n        }\r\n    } else if (expression.role === \"Application\") {\r\n        //Application\r\n        const [abstraction, argument] = expression.components;\r\n        return Apply(\r\n            Substitution(x, abstraction, substitute),\r\n            Substitution(x, argument, substitute)\r\n        );\r\n    }\r\n    const nothing: never = expression; //So TypeScript knows undefined will never be implicitly returned by the function.\r\n    return nothing;\r\n};"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "const Abstract = (x: VariableFree, expression: Lambda): Abstraction => {\r\n    const x_bound = Var(x.name, false);\r\n\r\n    //bind x.\r\n    const xBoundInExp = Substitution(x, expression, x_bound);\r\n\r\n    return {\r\n        role: \"Abstraction\",\r\n        components: [x_bound, xBoundInExp],\r\n        toString,\r\n    };\r\n};\r\n\r\nconst Apply = (expression1: Lambda, expression2: Lambda): Application => {\r\n    return {\r\n        role: \"Application\",\r\n        components: [expression1, expression2],\r\n        toString,\r\n    };\r\n};\r\n\r\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "ReferenceError",
                                "message": "Substitution is not defined",
                                "stack": "    at Abstract (<Cell 6> [5, 10])\n    at <Cell 6> [21, 0]\n    at <Cell 6> [20, 46]"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "const id_x = Abstract(x, x);\r\n//id_x"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "",
                                ""
                            ]
                        }
                    ]
                },
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "ReferenceError",
                                "message": "Substitution is not defined",
                                "stack": "    at Abstract (<Cell 6> [5, 10])\n    at <Cell 7> [1, 0]\n    at <Cell 7> [4, 46]"
                            }
                        }
                    ]
                }
            ]
        }
    ]
}